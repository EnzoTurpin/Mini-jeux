<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Maze with Three.js - Complex Maze</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #instructions {
        font-size: 24px;
        color: white;
      }
      #victoryMessage {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 32px;
        color: white;
        background-color: rgba(0, 0, 0, 0.75);
        padding: 20px;
        border-radius: 10px;
      }
      #minimap {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 200px;
        height: 200px;
        border: 2px solid white;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">Click to play</div>
    </div>
    <div id="victoryMessage">You Win!</div>
    <div id="minimap"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/controls/PointerLockControls.js"></script>
    <script>
      const mazeWidth = 21; // Must be an odd number
      const mazeHeight = 21; // Must be an odd number
      const cellSize = 1;

      // Main Scene, camera, renderer setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Mini-map Scene, camera, renderer setup
      const minimapScene = new THREE.Scene();
      const minimapCamera = new THREE.OrthographicCamera(
        -mazeWidth / 2,
        mazeWidth / 2,
        mazeHeight / 2,
        -mazeHeight / 2,
        0.1,
        100
      );
      minimapCamera.position.set(mazeWidth / 2, 50, mazeHeight / 2);
      minimapCamera.lookAt(mazeWidth / 2, 0, mazeHeight / 2);
      const minimapRenderer = new THREE.WebGLRenderer();
      minimapRenderer.setSize(200, 200);
      document
        .getElementById("minimap")
        .appendChild(minimapRenderer.domElement);

      // Add lights to both scenes
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      minimapScene.add(ambientLight.clone());

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(0, 10, 0).normalize();
      scene.add(directionalLight);
      minimapScene.add(directionalLight.clone());

      // PointerLockControls
      const controls = new THREE.PointerLockControls(camera, document.body);

      const blocker = document.getElementById("blocker");
      const instructions = document.getElementById("instructions");
      const victoryMessage = document.getElementById("victoryMessage");

      instructions.addEventListener("click", function () {
        controls.lock();
      });

      controls.addEventListener("lock", function () {
        instructions.style.display = "none";
        blocker.style.display = "none";
      });

      controls.addEventListener("unlock", function () {
        blocker.style.display = "flex";
        instructions.style.display = "";
      });

      scene.add(controls.getObject());

      // Initialize the maze grid
      const maze = [];
      for (let z = 0; z < mazeHeight; z++) {
        maze[z] = [];
        for (let x = 0; x < mazeWidth; x++) {
          maze[z][x] = 1; // Initialize all cells as walls
        }
      }

      // Maze generation using Depth-First Search (DFS)
      function generateMaze(x, z) {
        const stack = [];
        stack.push({ x, z });
        maze[z][x] = 0; // Start cell

        const directions = [
          { x: 0, z: -2 }, // Up
          { x: 2, z: 0 }, // Right
          { x: 0, z: 2 }, // Down
          { x: -2, z: 0 }, // Left
        ];

        while (stack.length > 0) {
          const cell = stack.pop();
          const shuffledDirections = directions.sort(() => 0.5 - Math.random());

          for (const dir of shuffledDirections) {
            const nx = cell.x + dir.x;
            const nz = cell.z + dir.z;
            const mx = cell.x + dir.x / 2;
            const mz = cell.z + dir.z / 2;

            if (nx > 0 && nx < mazeWidth && nz > 0 && nz < mazeHeight) {
              if (maze[nz][nx] === 1) {
                maze[nz][nx] = 0; // Mark the cell as a passage
                maze[mz][mx] = 0; // Remove the wall between cells
                stack.push({ x: nx, z: nz });
              }
            }
          }
        }
      }

      generateMaze(1, 1);

      // Store wall positions for collision detection
      const walls = [];
      const wallBoxes = [];

      // Function to create a wall segment
      function createWall(x, z) {
        const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const wall = new THREE.Mesh(geometry, material);
        wall.position.set(x * cellSize, cellSize / 2, z * cellSize);
        scene.add(wall);
        const wallClone = wall.clone();
        wallClone.position.set(x * cellSize, cellSize / 2, z * cellSize);
        minimapScene.add(wallClone);
        walls.push(wall);
        wallBoxes.push(new THREE.Box3().setFromObject(wall));
      }

      // Create maze in 3D
      for (let z = 0; z < mazeHeight; z++) {
        for (let x = 0; x < mazeWidth; x++) {
          if (maze[z][x] === 1) {
            createWall(x, z);
          }
        }
      }

      // Add floor to main scene
      const floorGeometry = new THREE.PlaneGeometry(
        mazeWidth * cellSize,
        mazeHeight * cellSize
      );
      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Add floor to minimap scene
      const miniFloorMaterial = new THREE.MeshStandardMaterial({
        color: 0x808080,
        side: THREE.DoubleSide,
      });
      const miniFloor = new THREE.Mesh(floorGeometry, miniFloorMaterial);
      miniFloor.rotation.x = -Math.PI / 2;
      minimapScene.add(miniFloor);

      // Camera position
      const cameraHeight = cellSize / 2;
      camera.position.set(1, cameraHeight, 1);

      // Create arrival point
      const arrivalGeometry = new THREE.BoxGeometry(
        cellSize,
        cellSize / 4,
        cellSize
      );
      const arrivalMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
      });
      const arrival = new THREE.Mesh(arrivalGeometry, arrivalMaterial);
      arrival.position.set(
        (mazeWidth - 2) * cellSize,
        cellSize / 8,
        (mazeHeight - 2) * cellSize
      );
      scene.add(arrival);
      const arrivalClone = arrival.clone();
      arrivalClone.position.set(
        (mazeWidth - 2) * cellSize,
        cellSize / 8,
        (mazeHeight - 2) * cellSize
      );
      minimapScene.add(arrivalClone);

      const arrivalBox = new THREE.Box3().setFromObject(arrival);

      // Create player indicator for minimap
      const playerGeometry = new THREE.BoxGeometry(
        cellSize,
        cellSize / 2,
        cellSize
      );
      const playerMaterial = new THREE.MeshStandardMaterial({
        color: 0x0000ff,
      });
      const playerIndicator = new THREE.Mesh(playerGeometry, playerMaterial);
      playerIndicator.position.set(
        camera.position.x,
        cameraHeight,
        camera.position.z
      );
      minimapScene.add(playerIndicator);

      // Movement controls
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const speed = 2.0; // Adjust speed as necessary
      let prevTime = performance.now();

      const onKeyDown = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
          case "KeyZ": // For AZERTY keyboards
            moveForward = true;
            break;
          case "ArrowLeft":
          case "KeyA":
          case "KeyQ": // For AZERTY keyboards
            moveLeft = true;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = true;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = true;
            break;
        }
      };

      const onKeyUp = function (event) {
        switch (event.code) {
          case "ArrowUp":
          case "KeyW":
          case "KeyZ": // For AZERTY keyboards
            moveForward = false;
            break;
          case "ArrowLeft":
          case "KeyA":
          case "KeyQ": // For AZERTY keyboards
            moveLeft = false;
            break;
          case "ArrowDown":
          case "KeyS":
            moveBackward = false;
            break;
          case "ArrowRight":
          case "KeyD":
            moveRight = false;
            break;
        }
      };

      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);

      // Collision detection
      function checkCollision(position) {
        const box = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(position.x, cameraHeight, position.z),
          new THREE.Vector3(0.5, cameraHeight, 0.5)
        );
        for (const wallBox of wallBoxes) {
          if (box.intersectsBox(wallBox)) {
            return true;
          }
        }
        return false;
      }

      // Check if player has reached the arrival point
      function checkArrival(position) {
        const box = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(position.x, cameraHeight, position.z),
          new THREE.Vector3(0.5, cameraHeight, 0.5)
        );
        return box.intersectsBox(arrivalBox);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        if (controls.isLocked === true) {
          const time = performance.now();
          const delta = (time - prevTime) / 1000;

          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize();

          if (moveForward || moveBackward)
            velocity.z += direction.z * speed * delta;
          if (moveLeft || moveRight) velocity.x += direction.x * speed * delta;

          // Get the direction the camera is facing
          const forward = new THREE.Vector3();
          camera.getWorldDirection(forward);

          // Calculate the right vector
          const right = new THREE.Vector3();
          right.crossVectors(camera.up, forward).normalize();

          // Calculate the new position
          const nextPosition = controls.getObject().position.clone();
          if (moveForward || moveBackward) {
            nextPosition.add(forward.multiplyScalar(velocity.z));
          }
          if (moveLeft || moveRight) {
            nextPosition.add(right.multiplyScalar(-velocity.x)); // Inverted direction fix
          }

          // Keep the camera at a constant height
          nextPosition.y = cameraHeight;

          // Check collision at next position
          if (!checkCollision(nextPosition)) {
            controls.getObject().position.copy(nextPosition);
          }

          // Check if arrival is reached
          if (checkArrival(nextPosition)) {
            victoryMessage.style.display = "block";
            controls.unlock();
          }

          // Update player indicator position
          playerIndicator.position.set(
            nextPosition.x,
            cameraHeight / 2,
            nextPosition.z
          );

          prevTime = time;
        }

        // Render the main scene
        renderer.render(scene, camera);

        // Render the minimap scene
        minimapRenderer.render(minimapScene, minimapCamera);
      }

      animate();
    </script>
  </body>
</html>
